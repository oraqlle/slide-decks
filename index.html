<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Structured C++</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night-alt.css">

		<!-- Theme used for syntax highlighted code -->
		<!-- <link rel="stylesheet" href="node_modules/@catppuccin/highlightjs/css/catppuccin-mocha.css"> -->
		<link rel="stylesheet" href="plugin/highlight/catppuccin-mocha-alt.css">

        <!-- Used for putting headings in the top left corner -->
        <link rel="stylesheet" href="css/custom/special-headers.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

                <!-- Title slide -->
				<section 
                    data-markdown="script/title.md"
                    data-separator="^\r?\n===\r?\n"
                    data-separator-vertical="^\r?\n---\r?\n">
                </section>

                <!-- Overview of topics covered in this meetup -->
				<section 
                    data-markdown="script/overview.md"
                    data-separator="^\r?\n===\r?\n"
                    data-separator-vertical="^\r?\n---\r?\n">
                </section>

                <!-- Definitions and terminology + Viewer Notes -->
                <section 
                    data-markdown="script/terminology.md"
                    data-separator="^\r?\n===\r?\n"
                    data-separator-vertical="^\r?\n---\r?\n">
                    <!-- TODO: Add drawings for each definition -->
                </section>

                <!-- Basic aggregate data structures -->
                <section 
                    data-markdown="script/aggregate-data-types/aggregate-data-types.md"
                    data-separator="^\r?\n===\r?\n"
                    data-separator-vertical="^\r?\n---\r?\n">
                </section>

                <!-- Data layouts in C++ -->
                <section id="Data Layout" data-auto-animate>
                    <h2>Data Layout</h2>
                </section>

                <section data-auto-animate>
                    <h2>Data Layout</h2>

                    <p>
                        C++ will generally compact the all the data of a type close together.
                    </p>
                        
                    <!-- Diagram of structures layout -->

                    <aside class="notes">
                        In C++, structures will (generally) have their members located right next to each other
                        in memory making the structure very compact. Which is part of C++'s goal for Zero Cost
                        Abstraction meaning what you don't use you don't pay for.
                    </aside>
                </section>

                <section data-auto-animate>
                    <section data-auto-animate>
                        <h2>Data Layout</h2>

                        <p style="font-size: xx-large;">
                            As we can see our structure only takes of up as much space as the sum of the sizes of its
                            members...
                        </p>
                            
                        <!-- New diagram with animation showing the size of members and total size -->

                        <p class="fragment" style="font-size: xx-large;">
                            ...almost. If we actually check this on <a href="https://godbolt.org/z/5hEfeaTK9">Godbolt</a>
                            using the <code>sizeof</code> operator we can see that our structures size is 12 bytes, not
                            9 bytes. Why has the compiler made <code>A</code> 3 bytes larger than it needs to be?
                        </p>

                        <!-- Take questions -->
                    </section>

                    <section>
                        <h3>Padding</h3>
                        
                        <p>
                            In some situations the compiler may add empty bytes; known as padding, around member variables
                            of a structure so that it is <i>"byte aligned"</i> or <i>"naturally aligned"</i>. This is done
                            to help optimises the CPU's ability to read and write to the address the member is located at.
                        </p>
                    </section>

                    <section data-auto-animate>
                        <h4>Natural Alignment</h4>
                        
                        <p style="font-size: xx-large;">
                            <i>Natural Alignment</i> means that a objects' starting memory address is a multiple of its size
                            in bytes.
                        </p>
                    </section>

                    <section data-auto-animate>
                        <h4>Natural Alignment</h4>
                        
                        <p style="font-size: xx-large;">
                            The CPU will always accesses memory by a single memory word at a time. Let's see how padding affects
                            how the CPU accesses memory when reading in a fixed size word with our <code>A</code> type.
                        </p>

                        <!-- auto-slide sections showing CPU reading memory one word at a time with svg's -->

                        <aside class="notes">
                            This means that the largest primitive data type supported by the computer must be able to fit into the
                            size of a memory word otherwise the CPU would have to access a single data type in chunks causing the
                            CPU to have to coordinate between two memory pages. Luckily most, if not all systems behave have a memory
                            word size that is at least as large as its largest supported primitive type.

                            However, when dealing structured data we often have data with different sizes. If they are packed
                            tightly together, the memory can become misaligned resulting in the split memory access issues mention
                            before. We can see this in our `A` type.
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <h4>CPU Memory Access (Packed Data)</h4>
                        
                        <p style="font-size: xx-large;">
                            Misaligned memory causes the CPU to fetch partial data meaning it need to find the missing data.
                        </p>

                        <!-- diagram of retrieved memory and how data has been left out using auto-slide and svgs -->

                        <aside class="notes">
                            Let's say we want to access each member of an instance of `A` and the members are packed right next to
                            each other. First the CPU with fetch the first full memory word size (assumed to be 64-bits or 8 bytes)
                            which will retrieve all of `chr`, `num` and only 3 bytes of `dec`, losing the rest. In order to operate
                            on `dec` the CPU would have to verify if the remaining bytes are available in its cache; as it may have
                            been lost along, retrieve them if they are not; performing a full RAM access request which is very costly
                            when you have the rest of the data ready, and combine it with the existing data of `dec`. This would
                            require lots of complex circuitry to achieve.
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <h4>CPU Memory Access (Padded Data)</h4>

                        <p style="font-size: xx-large;">
                            The compiler will add 3 bytes of padding after <code>chr</code> so that <code>dec</code> is naturally
                            aligned on the 32-bit boundary.
                        </p>

                        <!-- True structure diagram with auto-anim shift (2 slides) -->

                        <aside class="notes">
                            Instead, compilers will add padding so that certain datums start at some power-of-2 memory address
                            boundary. In this case, the compiler add 3 bytes of padding after `chr` so that any data for the member
                            `dec` is pushed out of the memory word containing `chr` and `num` which means the data of `dec` is not
                            split across memory words. This makes `num` now live on the 32-bit boundary line and `dec` on the
                            64-bit boundary line.
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <h4>CPU Memory Access (Padded Data)</h4>

                        <p style="font-size: xx-large;">
                            Now the CPU has a much easier time access memory correctly.
                        </p>

                        <!-- diagram of retrieved memory and how data isn't being left out anymore using auto-slide and svgs -->

                        <aside class="notes">
                            This dramatically reduced the logic the CPU needs to perform as it simply just fetches performs
                            another access to the needed datum (`dec`) and it can guarantee it will all be there. This is
                            a common theme in the relationship between software and hardware. Often by making certain things
                            true to the benefit of the hardwares design we can dramatically improve the performance of our
                            software.
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <h3>Application Binary Interface</h3>
                        
                        <p>
                            But how does the compiler <i>know</i> what shape to give a programming language's types and structures in memory?
                            To understand this we will need to look at how two programs interact.
                        </p>
                    </section>

                    <section data-auto-animate>
                        <h3>Application Binary Interface</h3>

                        <h4>API's</h4>
                        
                        <p>
                            The symbols you use from other modules form an Application Programming Interface (API) between your source
                            code and the other module.
                        </p>

                        <!-- Show example of source code importing a module -->

                        <aside class="notes">
                            When building a library you will often expose certain *symbols* which can be used in the source code of a
                            dependant program or library. The signature of these symbols; along with the semantics imposed by the
                            language these two programs are written in, creating the interface in which these two source code program
                            modules can interact with each other. This is know as an API (Application Programming Interface).
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <h3>Application Binary Interface</h3>

                        <p>
                            The manner in which two compiled (binary) modules/programs interact forms an Application Binary Interface
                            (ABI).
                        </p>

                        <!-- Show example of exe interacting with .so or other lib -->

                        <aside class="notes">
                            The compiled version of an API is what is known as the ABI (Application Binary Interface). An ABI is how
                            two binary program modules (ie. compiled source code) interact with each other. The ABI is usually defined
                            and implemented by compilers and describes how function/subroutines are executed, how types and structures
                            get mapped to memory etc. in a systems machine code.

                            Therefore, how structures are mapped onto memory is described by the systems ABI such that different binary
                            program modules can communicate and understand each other. This is essential because it is what allows your
                            programs to interact with your Operating System (OS) which is how it is able to execute!
                        </aside>
                    </section>

                    <section data-auto-animate>
                        <p>
                            Now that we have looked at some of the machine level details of C++'s structures lets move
                            back into some more language level constructs.
                        </p>
                    </section>
                </section>


                <!-- Access Control -->
                <section id="Access Control" data-auto-animate>
                    <h2>Access Control</h2>

                    <aside class="notes">
                        C++ allows us to control which members can be accessed from outside the class. This is done
                        with access modifier labels. These will apply to any members; data or function, below the
                        label in the types definition. Access modifiers allow use to encapsulate/internalize parts
                        of the type so it cannot be modified by anyone outside the type itself.
                    </aside>
                </section>

                <section data-auto-animate>
                    <h2>Access Control</h2>

                    <table>
                        <thead>
                            <tr>
                                <th class="tg-c3ow">Specifiers</th>
                                <th class="tg-c3ow">Same Class</th>
                                <th class="tg-c3ow">Derived Class</th>
                                <th class="tg-c3ow">Outside Class</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="tg-0pky"><code>public</code></td>
                                <td class="tg-c3ow">Yes</td>
                                <td class="tg-c3ow">Yes</td>
                                <td class="tg-c3ow">Yes</td>
                            </tr>
                            <tr>
                                <td class="tg-0pky"><code>private</code></td>
                                <td class="tg-c3ow">Yes</td>
                                <td class="tg-c3ow">No</td>
                                <td class="tg-c3ow">No</td>
                            </tr>
                            <tr>
                                <td class="tg-0pky"><code>protected</code></td>
                                <td class="tg-c3ow">Yes</td>
                                <td class="tg-c3ow">Yes</td>
                                <td class="tg-c3ow">No</td>
                            </tr>
                        </tbody>
                    </table>

                    <aside class="notes">
                        C++ has three access control labels, public, private and protected. `public` members can be
                        accessed from anyone outside the type and is used to define the API of our type. `private`
                        members are completely inaccessible to anything outside the type. `protected` labels members
                        that are private to anything outside the type except for types that are a part of the same
                        inheritance tree.
                        
                        We will look more at `protected` when we talk about virtual polymorphism.


                        Types declared with the `struct` keyword will have the `public` modifier applied to the
                        whole type by default.
                        
                        Types declared with the `class` keyword will have the `private` modifier applied to the
                        whole type by default.
                        
                        This is the only difference between the `class` and `struct` keyword in C++.
                    </aside>
                </section>

                <section data-auto-animate>
                    <h2>Access Control</h2>

                    <pre data-id="access-control-code"><code class="cpp" data-trim data-noescape data-line-numbers>
                        struct A {
                            char chr;
                            int num;
                            float dec;
                        };
                        
                        auto main() -> int {
                        
                            auto const a = A { .chr = 'a', .num = 123, .dec = 3.14f };
                        
                            // Reads data stored in members.
                            std::println("{}\n", a.chr);  // a
                            std::println("{}", a.num);  // 123
                            std::println("{}", a.dec);  // 3.14
                        
                            return 0;
                        }
                    </code></pre>
                </section>

                <section data-auto-animate>
                    <h2>Access Control</h2>

                    <pre data-id="access-control-code"><code class="cpp" data-trim data-noescape data-line-numbers>
                        struct A {
                            char chr;
                            int num;
                        
                        private:
                            float dec;
                        };
                        
                        auto main() -> int {
                        
                            auto a = A { };
                            a.chr = 'a';
                            a.num = 123;
                        
                            std::println("{}", a.chr);  // a
                            std::println("{}", a.num);  // 123
                            std::println("{}", a.dec);  //! Now fails to compile
                        
                            return 0;
                        }
                    </code></pre>

                    <p class="fragment" style="font-size: large;">
                        See it on Godbolt ⚡: <a href="https://godbolt.org/z/6PPqn9nsW">https://godbolt.org/z/6PPqn9nsW</a>
                    </p>
                </section>

                <!-- Operations -->
                <section id="Operations">
                    <h2>Defining Operations on Types</h2>
                </section>

                <!-- Handling Resources -->
                <section id="Handling Resources">
                    <h2>Handling Resources</h2>
                </section>

                <!-- Static Storage -->
                <section id="Static Storage">
                    <h2>Static Storage Duration</h2>
                </section>

                <!-- Data layouts in C++ -->
                <section id="Polymorphism">
                    <h2>Polymorphism</h2>
                </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
                slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
